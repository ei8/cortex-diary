@page "/tree"
@implements IDisposable
@using ei8.Cortex.Diary.Application.Subscriptions
@using ei8.Cortex.Diary.Domain.Model
@using ei8.Cortex.Diary.Port.Adapter.Common
@using ei8.Cortex.Diary.Port.Adapter.UI.Views.Blazor.ViewModels
@using ei8.Cortex.Diary.Application.Neurons
@using ei8.Cortex.Library.Client
@using ei8.Cortex.Library.Common
@using ei8.Cortex.Diary.Port.Adapter.UI.Views.Blazor.Modal
@using ei8.Cortex.Diary.Port.Adapter.UI.Views.Blazor.Graph
@using ei8.Cortex.Diary.Port.Adapter.UI.Views.Blazor.Shared
@using Blazorise.Icons.FontAwesome;
@using ei8.Cortex.Diary.Application.Settings
@using ei8.Cortex.Diary.Application.Identity
@using ei8.Cortex.Diary.Port.Adapter.IO.Process.Services.Settings
@using Microsoft.AspNetCore.Http
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.WebUtilities
@using IdentityServer4
@using System.Timers
@using ei8.Cortex.Subscriptions.Common
@using ei8.Cortex.Subscriptions.Common.Receivers
@using neurUL.Common.Http
@using System.Linq
@* Need further research how to implement custom toasts...
    @using Blazored.Toast
    @using Blazored.Toast.Services
    @using Blazored.Toast.Configuration
*@
@inject IHttpContextAccessor httpContextAccessor
@inject INeuronQueryService neuronQueryService
@inject INeuronApplicationService neuronApplicationService
@inject ITerminalApplicationService terminalApplicationService
@inject IToastService toastService
@inject NavigationManager navigationManager
@inject IJSRuntime jsRuntime
@inject ISettingsService settingsService
@inject IIdentityService identityService
@inject ISubscriptionApplicationService subscriptionApplicationService
@inject ISubscriptionQueryService subscriptionsQueryService

<NeuronContextMenu @bind-SelectedOption="@this.SelectedOption" @bind-IsVisible="@this.IsContextMenuVisible" />
<ConfirmationBox Title="Confirm Delete" Message='@this.ProcessSelectionTag("Are you sure you want to delete Neuron '{0}'?")' @bind-IsVisible="@this.IsConfirmVisible" OnConfirmCallback="@this.ConfirmDelete" />
<NeuronInfoBox @bind-SelectedNeuron="@this.SelectedNeuron" @bind-IsVisible="@this.IsInfoVisible" />
<AvatarUrlEditorBox @bind-NewAvatarUrl="@this.AvatarUrl" AvatarUrl="@this.AvatarUrl" @bind-IsVisible="@this.IsAvatarUrlVisible" />
<NeuronSearchBox AvatarUrl="@this.AvatarUrl" @bind-IsVisible="@this.IsSearchDefaultRegionNeuronVisible" @bind-SelectedNeuron="this.SelectedDefaultRegionNeuron" />

<div class="top-row px-4" style="padding-top:12px;z-index:1">
    <div class="details align-middle ">
        <button class="btn btn-light btn-sm rounded-circle" @onclick="this.Reload" style="height:32px;width:32px;" title="Reload">
            <Blazorise.Icon Name="FontAwesomeIcons.Redo" />
            @if (this.NewItemsCount > 0)
            {
                <Badge Pill="true" Color="Color.Danger" style="top:-35px;left:8px;height:14px;font-size:0.6em">@(this.NewItemsCount)</Badge>
            }
        </button>
        <input class="form-control form-control-sm ml-1 rounded " style="padding-right:33px" id="AvatarUrl" placeholder="Avatar URL" @bind="AvatarUrl" @onkeyup="@this.OnKeyPress" />
        <button style="position: absolute; right: 6.2rem; bottom:0.99rem;  height:1.6rem; border:0; border-radius:2px; background-color:white;   margin: 0;  " @onclick="this.ShowAvatarEditorBox"><i class="fas fa-edit"></i></button>
        <button class="btn btn-light btn-sm rounded-circle ml-1" @onclick="this.LoadGraph" style="height:32px; width:32px" title="Load Graph">
            <Blazorise.Icon Name="FontAwesomeIcons.CodeBranch" />
        </button>
        <Dropdown RightAligned="true" @ref="this.optionsDropdown">
            <button class="btn btn-light btn-sm ml-1 rounded-circle" @onclick="this.ShowOptionsMenu" title="Options">
                <Blazorise.Icon Name="FontAwesomeIcons.EllipsisV" Class="px-1" />
            </button>
            <Blazorise.DropdownMenu style="width: 250px">
                <DropdownItem @onclick="this.CopyAvatarUrl">
                    <Blazorise.Icon Name="FontAwesomeIcons.Clone" Class="px-2" />
                    Copy Direct Avatar URL
                </DropdownItem>
                <Dropdown Direction="Direction.Left">
                    <DropdownToggle>
                        <Blazorise.Icon Name="FontAwesomeIcons.Bell" Class="px-2" />
                        Subscribe
                    </DropdownToggle>
                    <DropdownMenu>
				        <DropdownItem @onclick="this.SubscribeWithBrowser">
					        <Blazorise.Icon Name="FontAwesomeIcons.Rocket" Class="px-2" />
					        Web Push
				        </DropdownItem>
                        <DropdownItem @onclick="this.SubscribeWithEmail">
					        <Blazorise.Icon Name="FontAwesomeIcons.Envelope" Class="px-2" />
					        E-mail
				        </DropdownItem>
                    </DropdownMenu>
                </Dropdown>
                <DropdownItem @onclick="this.ToggleRenderDirection">
                    <Blazorise.Icon Name="FontAwesomeIcons.Sort" Class="px-2" />
                    @if (this.RenderDirection == RenderDirectionValue.TopToBottom)
                    {
                        @((MarkupString)"First At Top")
                    }
                    else
                    {
                        @((MarkupString)"First At Bottom")
                    }
                </DropdownItem>
                <DropdownItem @onclick="this.SearchDefaultRegionNeuron">
                    <Blazorise.Icon Name="FontAwesomeIcons.SearchPlus" Class="px-2" />
                    Set Default Region ID
                </DropdownItem>
            </Blazorise.DropdownMenu>
        </Dropdown>
    </div>
</div>

@if (this.reloading)
{
    <div class="d-flex justify-content-center vh-100" style="padding-top: 300px">
        <div class="spinner-border" role="status">
            <span class="sr-only">Loading...</span>
        </div>
    </div>
}
else
{
    <div class="content px-0">
        <div class="treecontent">
            <div class="treecontent-item content px-lg-4 px-3">
                <TreeView AvatarUrl="@this.AvatarUrl" Children="@this.Children" @bind-SelectedNeuron="@this.SelectedNeuron" OnMenuRequested="@this.MenuRequested" OnInfoRequested="@this.InfoRequested" @bind-ControlsEnabled="@this.ControlsEnabled" @bind-RenderDirection="@this.RenderDirection" />
            </div>
            <div class="treecontent-item sticky-top" style="z-index:0">
                <div class="sticky-top" style="z-index:0">
                    <div class="modal modal-context" id="modal" style="height: 50px">
                        <div class="modal-body p-1">
                            <ul class="modal-list">
                                <li class="InnerOption" id="contextmenu">
                                    Link
                                </li>
                            </ul>
                        </div>
                    </div>
                    <span class="progress spinner-border text-primary none"></span>
                    <svg class="svgview" />
                </div>
            </div>
        </div>
    </div>
}
<div class="footer px-4 h-auto" style="z-index:2">
    <EditorBox AvatarUrl="@this.AvatarUrl" InitialRegionNeuron="@this.InitialRegionNeuron" InitialPostsynapticNeurons="@this.InitialPostsynapticNeurons" SelectedNeuron="@this.EditNeuron" @bind-SelectedOption="@this.SelectedOption" />
</div>

<audio id="sound" src=@(this.settingsService.BasePath + "/media/alert.wav") />

@code
{
    private bool reloading = true;
    private bool expandSubNavSettings;
    private Dropdown optionsDropdown;
    private Timer refreshTimer;
    private DotNetObjectReference<Tree>? dotNetHelper;

    private async void OnKeyPress(KeyboardEventArgs e)
    {
        if(e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            if(!string.IsNullOrEmpty(this.AvatarUrl))
                await this.Reload();
        }
    }

    private void ShowOptionsMenu()
    {
        if (this.optionsDropdown.Visible)
            this.optionsDropdown.Hide();
        else
            this.optionsDropdown.Show();

        // hide other dropdowns
        //this.userDropdown.Hide();
    }

    private void ShowAvatarEditorBox()
    {
        this.IsAvatarUrlVisible = true;
    }

    private void ToggleRenderDirection()
    {
        this.RenderDirection = this.RenderDirection == RenderDirectionValue.TopToBottom ?
            RenderDirectionValue.BottomToTop :
            RenderDirectionValue.TopToBottom;

        this.optionsDropdown.Hide();
    }

    [JSInvokable]
    public async Task<Boolean> SendLinkData(string sourceNeuronID, string targetNeuronID)
    {
        var result = false;
        await Blazor.Helper.UITryHandler(
            async () =>
            {
                if (QueryUrl.TryParse(this.AvatarUrl, out QueryUrl resultQuery))
                {
                    await Blazor.Helper.AddLink(this.terminalApplicationService, resultQuery.AvatarUrl, sourceNeuronID, targetNeuronID);
                }

                return true;
            },
            this.toastService,
            () => "Linking"
        );

        return result;
    }

    private void SearchDefaultRegionNeuron()
    {
        this.IsSearchDefaultRegionNeuronVisible = true;

        this.optionsDropdown.Hide();
    }

    protected override void OnInitialized()
    {
        this.Children = new List<TreeNeuronViewModel>();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            this.dotNetHelper = DotNetObjectReference.Create(this);
            await this.jsRuntime.InvokeAsync<string>("DotNetHelperSetter", this.dotNetHelper);
            var uri = this.navigationManager.ToAbsoluteUri(this.navigationManager.Uri);
            if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("direction", out var directionValue) &&
                Enum.TryParse<RenderDirectionValue>(directionValue, out RenderDirectionValue directionEnum)
                )
            {
                this.RenderDirection = directionEnum;
                this.StateHasChanged();
            }
            bool urlSet = false;
            var query = QueryHelpers.ParseQuery(uri.Query);
            if (query.TryGetValue("avatarUrl", out var encodedAvatarUrl))
            {
                Uri uriResult;
                string decodedUrl = Nancy.Helpers.HttpUtility.UrlDecode(encodedAvatarUrl);
                bool validUrl = Uri.TryCreate(decodedUrl, UriKind.Absolute, out uriResult)
                    && (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);
                if (validUrl)
                {
                    urlSet = true;
                    Neuron regionNeuron = null;
                    IEnumerable<Neuron> postsynapticNeurons = null;

                    if (Library.Client.QueryUrl.TryParse(decodedUrl, out QueryUrl urlResult))
                    {
                        if (query.TryGetValue("regionId", out var regionId))
                        {
                            regionNeuron = (await this.neuronQueryService.GetNeuronById(
                                urlResult.AvatarUrl,
                                regionId.ToString(),
                                new NeuronQuery()
                                ))?.Items.SingleOrDefault();
                        }

                        if (query.TryGetValue("postsynaptic", out var postsynaptics))
                        {
                            postsynapticNeurons = (await this.neuronQueryService.GetNeurons(
                                urlResult.AvatarUrl,
                                new NeuronQuery()
                                {
                                    Id = postsynaptics.ToArray()
                                }
                                ))?.Items;
                        }
                    }

                    await Task.Run(() =>
                    {
                        this.AvatarUrl = decodedUrl;
                        this.InitialRegionNeuron = regionNeuron;
                        this.InitialPostsynapticNeurons = postsynapticNeurons;
                        this.Reload();
                    });
                }
            }
            if (!urlSet)
                await this.SetReloading(false);

            this.refreshTimer = new Timer();
            this.refreshTimer.Interval = this.settingsService.UpdateCheckInterval;
            this.refreshTimer.Elapsed += OnTimerInterval;
            this.refreshTimer.AutoReset = true;
            // Start the timer
            this.refreshTimer.Enabled = true;

            // register push notification service worker
            var objRef = DotNetObjectReference.Create(this);
            await this.jsRuntime.InvokeVoidAsync("RegisterServiceWorker", objRef);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async void OnTimerInterval(object sender, ElapsedEventArgs e)
    {
        if (this.Children.Count() > 0)
        {
            try
            {
                var ns = await Tree.GetOrderedNeurons(this);
                var currentLastIndex = ns.ToList().FindLastIndex(nr => nr.Id == this.Children.Last().Neuron.Id);
                var newNeurons = ns.Where((n, i) => i > currentLastIndex && !this.Children.Any(nvm => nvm.Neuron.Id == n.Id));
                if (newNeurons.Count() > 0)
                {
                    if (this.NewItemsCount == 0)
                        await this.jsRuntime.InvokeAsync<string>("PlaySound");

                    this.NewItemsCount += newNeurons.Count();
                    newNeurons.ToList().ForEach(n => this.Children.Add(new TreeNeuronViewModel(new Neuron(n), this.AvatarUrl, this.neuronQueryService)));
                    await this.InvokeAsync(() => this.StateHasChanged());
                }
            }
            catch (Exception ex)
            {
                this.toastService.ShowError(ex.ToString());
            }
        }
    }

    public void Dispose()
    {
        // During prerender, this component is rendered without calling OnAfterRender and then immediately disposed
        // this mean timer will be null so we have to check for null or use the Null-conditional operator ?
        this.refreshTimer?.Dispose();
    }

    private async static Task<IEnumerable<Neuron>> GetOrderedNeurons(Tree value)
    {
        var ns = (await value.neuronQueryService.SendQuery(
                    value.AvatarUrl
                    )).Items;

        if (value.RenderDirection == RenderDirectionValue.BottomToTop)
            ns = ns.Reverse().ToArray();

        return ns;
    }

    private int NewItemsCount { get; set; } = 0;

    public string IdServerUrl { get; set; }

    [Parameter]
    public string AvatarUrl { get; set; }

    [Parameter]
    public IList<TreeNeuronViewModel> Children { get; set; } = new List<TreeNeuronViewModel>();

    private bool IsConfirmVisible { get; set; } = false;

    private bool IsContextMenuVisible { get; set; } = false;

    private bool IsInfoVisible { get; set; } = false;

    private bool IsAvatarUrlVisible { get; set; } = false;

    private RenderDirectionValue RenderDirection { get; set; } = RenderDirectionValue.TopToBottom;

    private NeuronResultItemViewModel selectedDefaultRegionNeuron;
    private NeuronResultItemViewModel SelectedDefaultRegionNeuron
    {
        get => this.selectedDefaultRegionNeuron;
        set
        {
            if (this.selectedDefaultRegionNeuron != value)
            {
                this.selectedDefaultRegionNeuron = value;

                if (this.selectedDefaultRegionNeuron != null)
                {
                    this.navigationManager.NavigateTo(
                        Tree.BuildAvatarUrl(this.navigationManager.Uri, this.AvatarUrl) + "&regionid=" + value.Neuron.Id,
                        true);
                    this.selectedDefaultRegionNeuron = null;
                }
            }
        }
    }

    private bool IsSearchDefaultRegionNeuronVisible { get; set; } = false;

    private ContextMenuOption selectedOption = ContextMenuOption.New;
    public ContextMenuOption SelectedOption
    {
        get => this.selectedOption;
        set
        {
            if (this.selectedOption != value)
            {
                this.selectedOption = value;
                switch (this.SelectedOption)
                {
                    case ContextMenuOption.New:
                        this.SelectedNeuron = null;
                        this.EditNeuron = null;
                        this.ControlsEnabled = true;
                        break;
                    case ContextMenuOption.Delete:
                        this.IsConfirmVisible = true;
                        break;
                    case ContextMenuOption.Edit:
                    case ContextMenuOption.AddRelative:
                        this.ControlsEnabled = false;
                        this.EditNeuron = this.SelectedNeuron.Neuron;
                        break;
                }
            }
        }
    }

    private bool ControlsEnabled { get; set; } = true;

    private TreeNeuronViewModel SelectedNeuron { get; set; } = null;

    private Neuron InitialRegionNeuron { get; set; } = null;

    private IEnumerable<Neuron> InitialPostsynapticNeurons { get; set; } = null;

    private Neuron editNeuron = null;
    private Neuron EditNeuron
    {
        get => this.editNeuron;
        set
        {
            this.editNeuron = value;
        }
    }

    private string ProcessSelectionTag(string format) => this.SelectedNeuron is TreeNeuronViewModel ?
            string.Format(format, this.SelectedNeuron.Neuron.Tag) :
            "[Error: Not a valid Neuron]";

    private async Task Reload()
    {
        await Blazor.Helper.UITryHandler(
            async () =>
            {
                await this.SetReloading(true);
                this.Children.Clear();
                var ns = await Tree.GetOrderedNeurons(this);
                var children = ns.Select(nr => new TreeNeuronViewModel(new Neuron(nr), this.AvatarUrl, this.neuronQueryService));
                ((List<TreeNeuronViewModel>)this.Children).AddRange(children);
                this.NewItemsCount = 0;

                if (this.RenderDirection == RenderDirectionValue.BottomToTop)
                    await this.ScrollToFragment("bottom");

                QueryUrl.TryParse(this.AvatarUrl, out QueryUrl result);
                this.serverPushPublicKey = (await this.subscriptionsQueryService.GetServerConfigurationAsync(result.AvatarUrl)).ServerPublicKey;

                var objRef = DotNetObjectReference.Create(this);
                await this.jsRuntime.InvokeVoidAsync("Subscribe", objRef, this.serverPushPublicKey);

                return false;
            },
            this.toastService,
            () => "Tree reload",
            postActionInvoker: async () =>
            {
                await this.SetReloading(false);
                await this.LoadGraph();
            }
        );
    }

    private async Task SetReloading(bool value)
    {
        this.reloading = value;
        await this.InvokeAsync(() => this.StateHasChanged());
    }

    private async Task ScrollToFragment(string elementId)
    {
        // https://github.com/WICG/scroll-to-text-fragment/
        if (!string.IsNullOrEmpty(elementId))
        {
            await this.jsRuntime.InvokeVoidAsync("BlazorScrollToId", elementId);
        }
    }

    private async void MenuRequested() => this.IsContextMenuVisible = true;

    private async void InfoRequested() => this.IsInfoVisible = true;

    private async void ConfirmDelete()
    {
        if (QueryUrl.TryParse(this.AvatarUrl, out QueryUrl result))
        {
            try
            {
                string description = string.Empty;

                if (this.SelectedNeuron.Neuron.Type == RelativeType.NotSet)
                {
                    await this.neuronApplicationService.DeactivateNeuron(
                        result.AvatarUrl,
                        this.SelectedNeuron.Neuron.Id,
                        this.SelectedNeuron.Neuron.Version
                        );
                    description = "Neuron removed";
                }
                else
                {
                    await this.terminalApplicationService.DeactivateTerminal(
                        result.AvatarUrl,
                        this.SelectedNeuron.Neuron.Terminal.Id,
                        this.SelectedNeuron.Neuron.Terminal.Version
                        );
                    description = "Terminal removed";
                }
                Blazor.Helper.ReinitializeOption(o => this.SelectedOption = o);

                this.toastService.ShowSuccess($"{description} successfully.");
            }
            catch (Exception ex)
            {
                this.toastService.ShowError(ex.Message);
            }
        }
    }

    private async Task LoadGraph()
    {
        var allNodes = new List<Node>();
        Tree.ExtractNodes(this.Children.ToArray(), allNodes);

        var distinctNodes = new List<Node>();
        // get distinct nodes
        allNodes.ForEach(n =>
        {
            if (!distinctNodes.Any(dn => dn.id == n.id))
                distinctNodes.Add(new Node() { id = n.id, tag = n.tag });
        });

        // get links
        var links = new List<Graph.Link>();
        Tree.ExtractLinks(this.Children.ToArray(), distinctNodes, links);

        await this.jsRuntime.InvokeVoidAsync("displayGraph", distinctNodes, links);
    }

    private static void ExtractNodes(IEnumerable<TreeNeuronViewModel> children, List<Node> allNodes)
    {
        allNodes.AddRange(children.Select(c => new Node { id = c.Neuron.Id, tag = c.Neuron.Tag }).ToArray());

        children.ToList().ForEach(c => Tree.ExtractNodes(c.Children, allNodes));
    }

    private static void ExtractLinks(IEnumerable<TreeNeuronViewModel> children, List<Node> distinctNodes, List<Graph.Link> links)
    {
        children.ToList().ForEach(c =>
        {
            if (c.Neuron.Type != RelativeType.NotSet)
            {
                var tsource = distinctNodes.FindIndex(n => n.id == c.Neuron.Terminal.PresynapticNeuronId);
                var ttarget = distinctNodes.FindIndex(n => n.id == c.Neuron.Terminal.PostsynapticNeuronId);

                var typeVal = (c.Neuron.Terminal.Strength == "1" ? "full" : "partial") + (c.Neuron.Terminal.Effect == "-1" ? "inhibit" : "excite");
                if (!links.Any(gl => gl.source == tsource && gl.target == ttarget))
                    links.Add(new Graph.Link() { source = tsource, target = ttarget, type = typeVal });
            }
        });

        children.ToList().ForEach(c => Tree.ExtractLinks(c.Children.ToArray(), distinctNodes, links));
    }

    private void CopyAvatarUrl()
    {
        jsRuntime.InvokeVoidAsync("copyToClipboard", Tree.BuildAvatarUrl(this.navigationManager.Uri, this.AvatarUrl));
        this.toastService.ShowInfo($"Copied successfully.");
        this.optionsDropdown.Hide();
    }

    private static string BuildAvatarUrl(string baseUrl, string avatarUrl)
    {
        var parsedBasedUrl = baseUrl.Substring(0, baseUrl.IndexOf("?") == -1 ? baseUrl.Length : baseUrl.IndexOf("?"));
        var prefixKeyword = "?avatarurl=";
        var encodedUrl = System.Net.WebUtility.UrlEncode(avatarUrl);
        return parsedBasedUrl + prefixKeyword + encodedUrl;
    }

    private async Task SubscribeWithBrowser()
    {
        QueryUrl.TryParse(this.AvatarUrl, out QueryUrl result);

        var subscriptionInfo = new SubscriptionInfo()
        {
            AvatarUrl = this.AvatarUrl
        };

        var receiverInfo = new BrowserReceiverInfo()
        {
            Name = this.deviceName,
            PushAuth = this.pushAuth,
            PushEndpoint = this.pushEndpoint,
            PushP256DH = this.pushP256DH
        };

        await this.subscriptionApplicationService.SubscribeAsync(result.AvatarUrl, subscriptionInfo, receiverInfo);
    }

    private async Task SubscribeWithEmail()
    {
        string emailDescription = string.Empty;

        await Blazor.Helper.UITryHandler(
            async () =>
            {
                QueryUrl.TryParse(this.AvatarUrl, out QueryUrl qu);

                var subscriptionInfo = new SubscriptionInfo()
                {
                    AvatarUrl = this.AvatarUrl
                };

                var e = this.httpContextAccessor.HttpContext.User?.Claims.SingleOrDefault(i => i.Type == "email");

                var result = e != null;

                if (result)
                {
                    emailDescription += " using '" + e.Value + "'";
                    var receiverInfo = new SmtpReceiverInfo()
                    {
                        EmailAddress = e.Value
                    };

                    await this.subscriptionApplicationService.SubscribeAsync(qu.AvatarUrl, subscriptionInfo, receiverInfo);
                }
                else
                    throw new InvalidOperationException("User not signed-in.");
            
                return result;
            },
            this.toastService,
            () => "E-mail Subscription" + emailDescription,
            () => this.optionsDropdown.Hide()
        );        
    }

    #region Subscription Interop
    private bool notificationsSupported = false;
    private bool serviceWorkerRegistered = false;
    private string permissionStatus = string.Empty;
    private string deviceName = string.Empty;
    private string pushP256DH;
    private string pushAuth;
    private string pushEndpoint;
    private string serverPushPublicKey;

    [JSInvokable]
    public void SetPermissionStatus(string status)
    {
        permissionStatus = status;
        StateHasChanged();
    }

    [JSInvokable]
    public void SetSupportState(bool isNotificationSupported)
    {
        notificationsSupported = isNotificationSupported;
        StateHasChanged();
    }

    [JSInvokable]
    public void SetServiceWorkerStatus(bool isRegistered)
    {
        serviceWorkerRegistered = isRegistered;
        StateHasChanged();
    }

    [JSInvokable]
    public void SetDeviceProperties(string name, string pushp256dh, string pushAuth, string pushEndpoint)
    {
        this.deviceName = name;
        this.pushP256DH = pushp256dh;
        this.pushAuth = pushAuth;
        this.pushEndpoint = pushEndpoint;
    }
    #endregion
}